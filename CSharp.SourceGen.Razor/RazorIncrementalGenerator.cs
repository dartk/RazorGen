using System.Collections.Immutable;
using System.Reflection;
using Microsoft.CodeAnalysis;


namespace CSharp.SourceGen.Razor;


[Generator(LanguageNames.CSharp)]
public class RazorIncrementalGenerator : IIncrementalGenerator
{
    private readonly RazorEngine _razorEngine;


    public RazorIncrementalGenerator()
    {
        // The source generator compiles a library with classes generated by razor and invokes each class.
        // Since the source generator targets netstandard2.0, the compiled library needs to reference
        // netstandard2.0 assemblies. In order to reliably reference netstandard2.0 assemblies, they are
        // included as embedded resources to the source generator assembly.
        this._netstandardReferences = GetNetstandardReferences();
        this._razorEngine = new RazorEngine();
    }


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = RazorTemplatesProvider().Combine(ProjectReferencesProvider());
        context.RegisterImplementationSourceOutput(provider, this.GenerateSources);
        return;

        // Non-empty additional files with '.razor' extension except those that start
        // with an underscore '_'
        IncrementalValueProvider<ImmutableArray<RazorTemplateSyntaxTree>>
            RazorTemplatesProvider()
        {
            return context.AdditionalTextsProvider
                .Select(static (file, token) =>
                {
                    var source = file.GetText(token)?.ToString() ?? string.Empty;
                    return new AdditionalFile(file.Path, source);
                })
                .Where(static file => file.IsNotEmpty
                    && file.FilePath.EndsWith(".razor",
                        StringComparison.InvariantCultureIgnoreCase)
                    && file.FileName[0] != '_'
                    && file.IsNotEmpty)
                .Select((file, _) =>
                    this._razorEngine.GenerateRazorTemplateSource(file).ToSyntaxTree())
                .Collect();
        }


        // Provides project's references if the the project targets netstandard2.0
        IncrementalValueProvider<ProjectReferencesInfo> ProjectReferencesProvider()
        {
            return IsTargetingNetstandardProvider()
                .Combine(context.CompilationProvider)
                .SelectMany((arg, _) =>
                {
                    var (isNetstandard, compilation) = arg;
                    var references = isNetstandard
                        ? compilation.References.OfType<PortableExecutableReference>()
                            .Where(reference => File.Exists(reference.FilePath))
                            .ToImmutableArray()
                        : ImmutableArray<PortableExecutableReference>.Empty;

                    return references;
                })
                .Select((reference, _) =>
                {
                    try
                    {
                        var assembly = Assembly.LoadFile(reference.FilePath!);
                        var name = assembly.GetName();
                        return new ReferenceInfo(reference, name);
                    }
                    catch
                    {
                        return null;
                    }
                })
                .Where(x => x is not null)
                .Collect()
                .Select((references, _) =>
                    ProjectReferencesInfo.FromReferenceInfoArray(references!));
        }


        IncrementalValueProvider<bool> IsTargetingNetstandardProvider()
        {
            return context.ParseOptionsProvider.Select((options, _) =>
                options.PreprocessorSymbolNames.Contains("NETSTANDARD2_0"));
        }
    }


    private void GenerateSources(SourceProductionContext context,
        (ImmutableArray<RazorTemplateSyntaxTree>, ProjectReferencesInfo) arg)
    {
        var (templates, projectReferences) = arg;

        try
        {
            var allReferences = projectReferences.References.Concat(this._netstandardReferences);
            var assemblyBytes = RazorEngine.EmitAssembly(templates.Select(x => x.SyntaxTree),
                allReferences, context.ReportDiagnostic);

            if (assemblyBytes == null)
            {
                return;
            }

            var assembly = Assembly.Load(assemblyBytes)
                ?? throw new NullReferenceException("Assembly is not loaded");

            var resultMethod = GetResultMethod(assembly)
                ?? throw new NullReferenceException("Result method not found");

            static MethodInfo GetResultMethod(Assembly assembly)
            {
                const string typeName = "TemplateBase";
                var type = assembly.GetType(typeName)
                    ?? throw new NullReferenceException($"Type '{typeName}' was not found");
                return type.GetMethod("Result")!;
            }

            // In Visual Studio assembly resolution is broken during manual project build and internal builds
            // for IntelliSense. It cannot detect assemblies that are already loaded into current AppDomain.
            // To solve the issue, manual handling of the AppDomain.AssemblyResolve event is used.
            using var resolver = AppDomainAssemblyResolver.Create(AppDomain.CurrentDomain,
                projectReferences.ReferencePathByFullName);

            foreach (var template in templates)
            {
                var type = assembly.GetType(template.TypeFullName);
                var obj = Activator.CreateInstance(type);
                Environment.CurrentDirectory = Path.GetDirectoryName(template.FileName);
                var renderedText = (string)resultMethod.Invoke(obj, Array.Empty<object>());
                context.AddSource(template.SuggestedGeneratedFileName(), renderedText);
            }
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(Error, Location.None, ex.ToString()));
        }
    }


    private static readonly DiagnosticDescriptor Error = new(
        id: $"{DiagnosticIdPrefix}001",
        title: "Razor Source Generator Error",
        messageFormat: "{0}",
        category: DiagnosticCategory,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);


    private readonly ImmutableArray<MetadataReference> _netstandardReferences;
    private const string DiagnosticIdPrefix = "SourceGen.Razor";
    private const string DiagnosticCategory = "CSharp.SourceGen.Razor";


    private static ImmutableArray<MetadataReference> GetNetstandardReferences()
    {
        var assembly = Assembly.GetExecutingAssembly();
        var resourceNames = assembly.GetManifestResourceNames();
        var builder = ImmutableArray.CreateBuilder<MetadataReference>(resourceNames.Length);
        foreach (var name in resourceNames)
        {
            using var stream = assembly.GetManifestResourceStream(name)!;
            var reference = MetadataReference.CreateFromStream(stream);
            builder.Add(reference);
        }

        return builder.MoveToImmutable();
    }
}


public record ReferenceInfo(PortableExecutableReference Reference, AssemblyName AssemblyName)
{
    public string FilePath => this.Reference.FilePath!;
}


public readonly record struct PathByFullNameDictionary(
    IReadOnlyDictionary<string, string> Dictionary);


public record ProjectReferencesInfo(
    ImmutableArray<MetadataReference> References,
    PathByFullNameDictionary ReferencePathByFullName)
{
    public static ProjectReferencesInfo FromReferenceInfoArray(
        ImmutableArray<ReferenceInfo> referenceInfoArray)
    {
        var referencesBuilder =
            ImmutableArray.CreateBuilder<MetadataReference>(referenceInfoArray.Length);
        var dictionary = new Dictionary<string, string>(referenceInfoArray.Length);
        foreach (var reference in referenceInfoArray)
        {
            referencesBuilder.Add(reference.Reference);
            dictionary[reference.AssemblyName.FullName] = reference.FilePath;
        }

        return new ProjectReferencesInfo(
            referencesBuilder.MoveToImmutable(),
            new PathByFullNameDictionary(dictionary));
    }
}